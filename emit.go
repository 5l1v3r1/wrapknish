package main

import (
    "fmt"
    "io"
    "log"
    "bytes"
    "go/ast"
    "go/token"
)

const RECV_OBJ_NAME = "_recv_o"

func getUnnamedParamName(index int) (string) {
    return fmt.Sprintf("param_%d", index)
}

func emitParamList(w io.Writer, params *ast.FieldList, emitTypes bool, generateMissingNames bool) {
    if params != nil && len(params.List) > 0 {
        for paramIndex, param := range params.List {
            emitFieldListSeparator(w, paramIndex)

            if param.Names == nil || len(param.Names) == 0 {
                if generateMissingNames {
                    tempName := getUnnamedParamName(paramIndex)
                    emit(w, "%s", tempName)
                    if emitTypes {
                        emit(w, " ")
                    }
                }
            } else {
                for nameIndex, n := range param.Names {
                    emitFieldListSeparator(w, nameIndex)
                    emit(w, "%s", n.Name)
                    if emitTypes && nameIndex == len(param.Names) - 1 {
                        emit(w, " ")
                    }
                }
            }
            if emitTypes {
                emitType(w, param.Type)
            } else if _, isEllipsis := param.Type.(*ast.Ellipsis); isEllipsis {
                emit(w, "...")
            }
        }
    }
}

func emitPassedParamList(w io.Writer, params *ast.FieldList) {
    emitParamList(w, params, false, true)
}

func emitResultsList(w io.Writer, results *ast.FieldList) {
    emitParamList(w, results, true, false)
}

func emitFuncType(w io.Writer, x *ast.FuncType) {
    emit(w, "func(")
    emitParamList(w, x.Params, true, false)
    emit(w, ")")
    if x.Results != nil && len(x.Results.List) > 0 {
        emit(w, " ")
        if len(x.Results.List) > 1 {
            emit(w, "(")
        }
        emitResultsList(w, x.Results)
        if len(x.Results.List) > 1 {
            emit(w, ")")
        }
    }
}

func getFuncRecvType(x *ast.FuncDecl) string {
    if x.Recv == nil {
        return ""
    }

    typeNameBuffer := new(bytes.Buffer)
    emitType(typeNameBuffer, x.Recv.List[0].Type)
    return typeNameBuffer.String()
}

func emitFuncWrapper(w io.Writer, x *ast.FuncDecl, overrides *WrapperOverrides, origPkg string) {
    if !ast.IsExported(x.Name.Name) {
        return
    }

    recvTypeName := getFuncRecvType(x)
    recvUnderlyingTypeName := recvTypeName

    if recvTypeName == "" {
        // this is a function
        if overrides.IsFuncOverridden(x.Name.Name) {
            log.Printf("function %s is overridden -- skipping wrapper\n", x.Name.Name)
            return
        }
    } else {
        // this is a method
        if recvUnderlyingTypeName[0] == '*' {
            recvUnderlyingTypeName = recvUnderlyingTypeName[1:]
        }

        // yes, this is an idiotic name
        typeOverrideType := overrides.GetTypeOverride(recvUnderlyingTypeName)

        if overrides.IsMethodOverridden(recvUnderlyingTypeName, x.Name.Name) {
            if typeOverrideType == TYPE_OVERRIDE_NONE {
                fatal("cannot override method %s.%s() without overriding type %s\n", recvUnderlyingTypeName, x.Name.Name, recvUnderlyingTypeName)
            }
            log.Printf("method %s.%s() is overridden -- skipping wrapper\n", recvUnderlyingTypeName, x.Name.Name)
            return
        } else {
            // method is not overridden
            switch (typeOverrideType) {
            case TYPE_OVERRIDE_NONE:
                // if type is not overridden either, we can skip this, since it will be pulled in by our type alias.
                return
            // TODO: at this point, no types are marked this way.
            case TYPE_OVERRIDE_NO_METHODS:
                fatal("type %s is marked for complete manual override, but method %s.%s() is not overridden\n", recvUnderlyingTypeName,
                    recvUnderlyingTypeName, x.Name.Name)
            case TYPE_OVERRIDE_AUTO_WRAP_METHODS:
                // this case is supported
                log.Printf("wrapper for method %s.%s() will be autogenerated\n", recvUnderlyingTypeName, x.Name.Name)
            default:
                fatal("unexpected override type %d\n", typeOverrideType)
            }
        }
    }

    emit(w, "func ")
    if recvTypeName != "" {
        emit(w, "(%s %s) ", RECV_OBJ_NAME, recvTypeName)
    }
    emit(w, "%s(", x.Name.Name)
    emitParamList(w, x.Type.Params, true, true)
    emit(w, ") ")

    hasReturns := x.Type.Results != nil && len(x.Type.Results.List) > 0

    if hasReturns {
        if len(x.Type.Results.List) > 1 {
            emit(w, "(")
        }
        emitResultsList(w, x.Type.Results)
        if len(x.Type.Results.List) > 1 {
            emit(w, ")")
        }
        emit(w, " ")
    }
    emit(w, "{ ")
    if hasReturns {
        emit(w, "return ")
    }
    if recvTypeName != "" {
        emit(w, "(*%s.%s).%s((*%s.%s)(%s), ", origPkg, recvUnderlyingTypeName, x.Name.Name, origPkg, recvUnderlyingTypeName, RECV_OBJ_NAME)
    } else {
        emit(w, "%s.%s(", origPkg, x.Name.Name)
    }
    emitPassedParamList(w, x.Type.Params)
    emit(w, ") }\n")
}

func emitImportSpecs(w io.Writer, specs []ast.Spec) {
    if len(specs) == 0 {
        return
    }

    emit(w, "import (\n")
    for _, spec := range specs {
        emit(w, "    ")
        v := spec.(*ast.ImportSpec)
        if v.Name != nil {
            emit(w, "%s ", v.Name.Name)
        }
        emit(w, "%s\n", v.Path.Value)
    }
    emit(w, ")\n\n")
}

func emitTypeSpecs(w io.Writer, specs []ast.Spec, overrides *WrapperOverrides, origPkg string) {
    emitted := false
    for _, spec := range specs {
        v := spec.(*ast.TypeSpec)
        if !ast.IsExported(v.Name.Name) {
            continue
        }
        if overrides.GetTypeOverride(v.Name.Name) != TYPE_OVERRIDE_NONE {
            log.Printf("type %s is overridden -- skipping wrapper\n", v.Name.Name)
            continue
        }
        emitted = true
        emit(w, "type %s = %s.%s\n", v.Name.Name, origPkg, v.Name.Name)
    }
    if emitted {
        emitNewline(w)
    }
}

func hasExportedName(spec *ast.ValueSpec, overrides *WrapperOverrides) (bool) {
    for _, n := range spec.Names {
        if ast.IsExported(n.Name) && !overrides.IsVarOverridden(n.Name) {
            return true
        }
    }
    return false
}

func emitValueSpecs(w io.Writer, specs []ast.Spec, overrides *WrapperOverrides, origPkg string) {
    for _, spec := range specs {
        v := spec.(*ast.ValueSpec)

        if !hasExportedName(v, overrides) {
            continue
        }

        if !isAllowedGlobalPointer(v) {
            emit(w, "// WARNING: unsupported variable type %T for %+v\n", v, v.Names)
            // fatal("unsupported value type")
        }
        log.Printf("supporting mutable pointer for %+v\n", v)

        for _, name := range v.Names {
            // TODO: clean this up
            if !ast.IsExported(name.Name) {
                continue
            }
            if overrides.IsVarOverridden(name.Name) {
                log.Printf("var %s is overridden -- skipping wrapper\n", name.Name)
                continue
            }
            emit(w, "var %s = %s.%s\n", name.Name, origPkg, name.Name)
        }
    }
}

func emitValueSpec(w io.Writer, spec *ast.ValueSpec, prefix string) {
    for i, n := range spec.Names {
        emit(w, "%s%s", prefix, n.Name)
        // i.e., const ABC = "def"
        if spec.Type != nil {
            emit(w, " ")
            emitType(w, spec.Type)
        }
        if spec.Values != nil && len(spec.Values) > i {
            v := spec.Values[i]
            emit(w, " = ")
            emitValue(w, v)
        }
        emitNewline(w)
    }
}

func emitConstSpecs(w io.Writer, specs []ast.Spec, overrides *WrapperOverrides) {
    // TODO: cleanup
    exportedCount := 0
    for _, s := range specs {
        v := s.(*ast.ValueSpec)
        if hasExportedName(v, overrides) {
            exportedCount += 1
            if exportedCount > 1 {
                break
            }
        }
    }
    if exportedCount == 1 {
        for _, s := range specs {
            v := s.(*ast.ValueSpec)
            if hasExportedName(v, overrides) {
                emitValueSpec(w, v, "const ")
                break
            }
        }
    } else if exportedCount > 0 {
        // this is necessary for iota const clauses
        emit(w, "const (\n")
        for _, spec := range specs {
            v := spec.(*ast.ValueSpec)
            if hasExportedName(v, overrides) {
                emitValueSpec(w, v, "    ")
            }
        }
        emit(w, ")\n")
    }
}

func emitGenDecl(w io.Writer, g *ast.GenDecl, overrides *WrapperOverrides, origPkg string) {
    switch g.Tok {
    case token.IMPORT:
        emitImportSpecs(w, g.Specs)
    case token.TYPE:
        emitTypeSpecs(w, g.Specs, overrides, origPkg)
    case token.VAR:
        emitValueSpecs(w, g.Specs, overrides, origPkg)
    case token.CONST:
        emitConstSpecs(w, g.Specs, overrides)
    default:
        log.Printf("encountered unexpected type %d (%T): %+v\n", g.Tok, g, g)
        fatal("gendecl has invalid type")
    }
}

func emitFileWrapper(w io.Writer, f *ast.File, overrides *WrapperOverrides, origPkg string) {
    for _, decl := range f.Decls {
        switch v := decl.(type) {
        case *ast.GenDecl:
            emitGenDecl(w, v, overrides, origPkg)
        case *ast.FuncDecl:
            emitFuncWrapper(w, v, overrides, origPkg)
        default:
            log.Printf("unsupported declaration of type %T: %+v\n", v, v)
            fatal("unsupported declaration type")
        }
    }
}

